<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>縦スクロールシューティングゲーム</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background-color: #000;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }
    canvas {
      border: 2px solid #fff;
      max-width: 100%;
      max-height: 100%;
      touch-action: none;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="480" height="720"></canvas>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const player = {
      x: canvas.width / 2 - 25,
      y: canvas.height - 60,
      width: 50,
      height: 50
    };

    let isGameStarted = false;
    let isGameOver = false;
    let score = 0;
    let lives = 3;
    let backgroundOffset = 0;
    let enemies = [];
    let bullets = [];
    let recoveryItems = [];
    let playerSpeed = 6;
    let speedUpInterval = 30000;
    let speedIncrease = 1;
    let lastSpeedUpTime = Date.now();

    function resetGame() {
      isGameOver = false;
      score = 0;
      lives = 3;
      bullets = [];
      enemies = [];
      recoveryItems = [];
      player.x = canvas.width / 2 - 25;
      player.y = canvas.height - 60;
      lastSpeedUpTime = Date.now();
    }

    function drawRect(obj, color) {
      ctx.fillStyle = color;
      ctx.fillRect(obj.x, obj.y, obj.width, obj.height);
    }

    function drawText(text, x, y, size = 20, color = 'white', align = 'left') {
      ctx.font = `${size}px sans-serif`;
      ctx.fillStyle = color;
      ctx.textAlign = align;
      ctx.fillText(text, x, y);
    }

    function drawHearts(x, y, count) {
      ctx.font = '24px sans-serif';
      ctx.fillStyle = 'red';
      ctx.textAlign = 'left';
      ctx.fillText('❤'.repeat(count), x, y);
    }

    function spawnRecoveryItem() {
      if (Math.random() < 0.01) {
        recoveryItems.push({
          x: Math.random() * canvas.width,
          y: 0,
          width: 20,
          height: 20,
          speed: 2,
        });
      }
    }

    function updateRecoveryItems() {
      for (let item of recoveryItems) {
        item.y += item.speed;
      }
      recoveryItems = recoveryItems.filter(item => item.y < canvas.height);
    }

    function checkRecoveryItemCollision() {
      for (let i = recoveryItems.length - 1; i >= 0; i--) {
        const item = recoveryItems[i];
        if (player.x < item.x + item.width &&
            player.x + player.width > item.x &&
            player.y < item.y + item.height &&
            player.y + player.height > item.y) {
          if (lives < 3) lives++;
          recoveryItems.splice(i, 1);
        }
      }
    }

    function spawnEnemy() {
      if (Math.random() < 0.02) {
        enemies.push({
          x: Math.random() * (canvas.width - 40),
          y: -40,
          width: 40,
          height: 40,
          dx: Math.random() > 0.5 ? 1.5 : -1.5
        });
      }
    }

    function resetPlayerPosition() {
      player.x = canvas.width / 2 - player.width / 2;
      player.y = canvas.height - 60;
    }

    function update() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (!isGameStarted) {
        drawText("縦スクロールシューティング", canvas.width / 2, 250, 24, 'white', 'center');
        drawText("タップまたはスペースキーでスタート", canvas.width / 2, 300, 16, 'gray', 'center');
        return;
      }

      if (isGameOver) {
        drawText("GAME OVER", canvas.width / 2, 300, 36, 'red', 'center');
        drawText(`SCORE: ${score}`, canvas.width / 2, 350, 18, 'white', 'center');
        drawText("スペースまたはタップでリトライ", canvas.width / 2, 390, 16, 'gray', 'center');
        return;
      }

      if (Date.now() - lastSpeedUpTime > speedUpInterval) {
        lastSpeedUpTime = Date.now();
        playerSpeed += speedIncrease;
      }

      spawnRecoveryItem();
      updateRecoveryItems();
      checkRecoveryItemCollision();

      backgroundOffset += 2;
      spawnEnemy();

      bullets.forEach(b => b.y -= 5);
      bullets = bullets.filter(b => b.y > 0);

      enemies.forEach(e => {
        e.y += 2;
        e.x += e.dx;
        if (e.x < 0 || e.x > canvas.width - e.width) e.dx *= -1;
      });
      enemies = enemies.filter(e => e.y < canvas.height);

      for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        for (let j = bullets.length - 1; j >= 0; j--) {
          const b = bullets[j];
          if (b.x < e.x + e.width &&
              b.x + b.width > e.x &&
              b.y < e.y + e.height &&
              b.y + b.height > e.y) {
            enemies.splice(i, 1);
            bullets.splice(j, 1);
            score += 100;
            break;
          }
        }
      }

      for (let e of enemies) {
        if (player.x < e.x + e.width &&
            player.x + player.width > e.x &&
            player.y < e.y + e.height &&
            player.y + player.height > e.y) {
          lives--;
          if (lives <= 0) {
            isGameOver = true;
          } else {
            resetPlayerPosition();
          }
        }
      }

      ctx.strokeStyle = '#333';
      for (let i = 0; i < canvas.height / 40; i++) {
        let y = (i * 40 + backgroundOffset) % canvas.height;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }

      drawRect(player, 'white');
      bullets.forEach(b => drawRect(b, 'cyan'));
      enemies.forEach(e => drawRect(e, 'red'));
      recoveryItems.forEach(item => drawRect(item, 'green'));

      drawText(`SCORE: ${score}`, 10, 30);
      drawHearts(canvas.width - 80, 30, lives);
    }

    document.addEventListener('keydown', (e) => {
      if (e.key === ' ') {
        if (!isGameStarted || isGameOver) {
          resetGame();
          isGameStarted = true;
        } else {
          bullets.push({
            x: player.x + player.width / 2 - 2,
            y: player.y,
            width: 4,
            height: 10
          });
        }
      }
      if (isGameStarted && !isGameOver) {
        if (e.key === 'ArrowLeft') player.x -= playerSpeed;
        if (e.key === 'ArrowRight') player.x += playerSpeed;
      }
    });

    canvas.addEventListener('touchstart', (e) => {
      const touch = e.touches[0];
      if (!isGameStarted || isGameOver) {
        resetGame();
        isGameStarted = true;
      } else {
        bullets.push({
          x: player.x + player.width / 2 - 2,
          y: player.y,
          width: 4,
          height: 10
        });
      }
    });

    canvas.addEventListener('touchmove', (e) => {
      const touch = e.touches[0];
      const canvasRect = canvas.getBoundingClientRect();
      const x = touch.clientX - canvasRect.left;
      player.x = x - player.width / 2;
      if (player.x < 0) player.x = 0;
      if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;
    });

    function gameLoop() {
      update();
      requestAnimationFrame(gameLoop);
    }

    gameLoop();
  </script>
</body>
</html>
